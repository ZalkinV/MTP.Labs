kernel void firstImpl(
	global const float* firstMatrix,
	global const float* secondMatrix,
	const int rowsCount,
	const int colsRowsCount,
	const int colsCount,
	global float* matrixResult)
{
	const int iRow = get_global_id(0);
	const int iCol = get_global_id(1);


	float elValue = 0;
	for (int iEl = 0; iEl < colsRowsCount; iEl++)
	{
		elValue += firstMatrix[iRow * colsRowsCount + iEl] * secondMatrix[iEl * colsCount + iCol];
	}

	matrixResult[iRow * colsCount + iCol] = elValue;
}

kernel void secondImpl(
	global const float* firstMatrix,
	global const float* secondMatrix,
	const int rowsCount,
	const int colsRowsCount,
	const int colsCount,
	global float* resultMatrix)
{
	const int globalRowsCount = get_global_size(0);
	const int globalColsCount = get_global_size(1);

	const int iRow = get_global_id(0);
	const int iCol = get_global_id(1);

	const int iGroupRow = get_group_id(0);
	const int iGroupCol = get_group_id(1);

	const int iRowLoc = get_local_id(0);
	const int iColLoc = get_local_id(1);

	local float fMatGroup[LOCAL_GROUP_SIZE][LOCAL_GROUP_SIZE];
	local float sMatGroup[LOCAL_GROUP_SIZE][LOCAL_GROUP_SIZE];


	float elValue = 0;

	const int fsSubMatCount = (int)ceil(colsRowsCount / (float)LOCAL_GROUP_SIZE);
	for (int iSubMat = 0; iSubMat < fsSubMatCount; iSubMat++)
	{
		const int fMatRow = iGroupRow * LOCAL_GROUP_SIZE + iRowLoc;
		const int fMatCol = iSubMat * LOCAL_GROUP_SIZE + iColLoc;
		if (fMatRow < rowsCount && fMatCol < colsRowsCount)
			fMatGroup[iRowLoc][iColLoc] = firstMatrix[fMatRow * colsRowsCount + fMatCol];
		else
			fMatGroup[iRowLoc][iColLoc] = 0;

		const int sMatRow = iSubMat * LOCAL_GROUP_SIZE + iRowLoc;
		const int sMatCol = iGroupCol * LOCAL_GROUP_SIZE + iColLoc;
		if (sMatRow < colsRowsCount && sMatCol < colsCount)
			sMatGroup[iRowLoc][iColLoc] = secondMatrix[sMatRow * colsCount + sMatCol];
		else
			sMatGroup[iRowLoc][iColLoc] = 0;


		for (int iEl = 0; iEl < LOCAL_GROUP_SIZE; iEl++)
		{
			elValue += fMatGroup[iRowLoc][iEl] * sMatGroup[iEl][iColLoc];
		}
	}

	if (iRow < rowsCount && iCol < colsCount)
		resultMatrix[iRow * colsCount + iCol] = elValue;
}

kernel void secondVectorImpl(
	global const float* firstMatrix,
	global const float* secondMatrix,
	const int rowsCount,
	const int colsRowsCount,
	const int colsCount,
	global float* resultMatrix)
{
	const int globalRowsCount = get_global_size(0);
	const int globalColsCount = get_global_size(1);

	const int iRow = get_global_id(0);
	const int iCol = get_global_id(1);

	const int iGroupRow = get_group_id(0);
	const int iGroupCol = get_group_id(1);

	const int iRowLoc = get_local_id(0);
	const int iColLoc = get_local_id(1);

	local float fMatGroup[LOCAL_GROUP_SIZE][LOCAL_GROUP_SIZE];
	local float sMatGroup[LOCAL_GROUP_SIZE][LOCAL_GROUP_SIZE];


	float8 resVector;

	const int fsSubMatCount = (int)ceil(colsRowsCount / (float)LOCAL_GROUP_SIZE);
	for (int iSubMat = 0; iSubMat < fsSubMatCount; iSubMat++)
	{
		const int fMatRow = iGroupRow * LOCAL_GROUP_SIZE + iRowLoc;
		const int fMatCol = iSubMat * LOCAL_GROUP_SIZE + iColLoc;
		if (fMatRow < rowsCount && fMatCol < colsRowsCount)
			fMatGroup[iRowLoc][iColLoc] = firstMatrix[fMatRow * colsRowsCount + fMatCol];
		else
			fMatGroup[iRowLoc][iColLoc] = 0;

		const int sMatRow = iSubMat * LOCAL_GROUP_SIZE + iRowLoc;
		const int sMatCol = iGroupCol * LOCAL_GROUP_SIZE + iColLoc;
		if (sMatRow < colsRowsCount && sMatCol < colsCount)
			sMatGroup[iRowLoc][iColLoc] = secondMatrix[sMatRow * colsCount + sMatCol];
		else
			sMatGroup[iRowLoc][iColLoc] = 0;
			

		const int vectorsCount = LOCAL_GROUP_SIZE / 8;
		for (int iVector = 0; iVector < vectorsCount; iVector++)
		{
			const int iVectorEl = iVector * vectorsCount;
			const float8 fMatRow = (float8)(fMatGroup[iRowLoc][iVectorEl + 0],
											fMatGroup[iRowLoc][iVectorEl + 1],
											fMatGroup[iRowLoc][iVectorEl + 2],
											fMatGroup[iRowLoc][iVectorEl + 3],
											fMatGroup[iRowLoc][iVectorEl + 4],
											fMatGroup[iRowLoc][iVectorEl + 5],
											fMatGroup[iRowLoc][iVectorEl + 6],
											fMatGroup[iRowLoc][iVectorEl + 7]);
			const float8 sMatCol = (float8)(sMatGroup[iVectorEl + 0][iColLoc],
											sMatGroup[iVectorEl + 1][iColLoc],
											sMatGroup[iVectorEl + 2][iColLoc],
											sMatGroup[iVectorEl + 3][iColLoc],
											sMatGroup[iVectorEl + 4][iColLoc],
											sMatGroup[iVectorEl + 5][iColLoc],
											sMatGroup[iVectorEl + 6][iColLoc],
											sMatGroup[iVectorEl + 7][iColLoc]);
			resVector += fMatRow * sMatCol;
		}
	}

	if (iRow < rowsCount && iCol < colsCount)
		resultMatrix[iRow * colsCount + iCol] = resVector.s0 + resVector.s1 + resVector.s2 + resVector.s3 + resVector.s4 + resVector.s5 + resVector.s6 + resVector.s7;
}

kernel void thirdImpl(
	global const float* firstMatrix,
	global const float* secondMatrix,
	const int rowsCount,
	const int colsRowsCount,
	const int colsCount,
	global float* resultMatrix)
{
	const int globalRowsCount = get_global_size(0);
	const int globalColsCount = get_global_size(1);

	const int iRow = get_global_id(0) * VEC_SIZE;
	const int iCol = get_global_id(1) * VEC_SIZE;

	const int iGroupRow = get_group_id(0);
	const int iGroupCol = get_group_id(1);

	const int iRowLoc = get_local_id(0) * VEC_SIZE;
	const int iColLoc = get_local_id(1) * VEC_SIZE;

	local float fMatGroup[LOCAL_GROUP_SIZE * VEC_SIZE][LOCAL_GROUP_SIZE * VEC_SIZE];
	local float sMatGroup[LOCAL_GROUP_SIZE * VEC_SIZE][LOCAL_GROUP_SIZE * VEC_SIZE];


	float4 elsValues;

	const int fsSubMatCount = (int)ceil(colsRowsCount / (float)LOCAL_GROUP_SIZE);
	for (int iSubMat = 0; iSubMat < fsSubMatCount; iSubMat++)
	{
		for (int iVecEl = 0; iVecEl < VEC_SIZE * VEC_SIZE; iVecEl++)
		{
			const uint vecRowShift = iRowLoc + iVecEl / VEC_SIZE;
			const uint vecColShift = iColLoc + iVecEl % VEC_SIZE;

			const int fMatRow = iGroupRow * LOCAL_GROUP_SIZE + vecRowShift;
			const int fMatCol = iSubMat * LOCAL_GROUP_SIZE + vecColShift;
			if (fMatRow < rowsCount && fMatCol < colsRowsCount)
				fMatGroup[vecRowShift][vecColShift] = firstMatrix[fMatRow * colsRowsCount + fMatCol];
			else
				fMatGroup[vecRowShift][vecColShift] = 0;

			const int sMatRow = iSubMat * LOCAL_GROUP_SIZE + vecRowShift;
			const int sMatCol = iGroupCol * LOCAL_GROUP_SIZE + vecColShift;
			if (sMatRow < colsRowsCount && sMatCol < colsCount)
				sMatGroup[vecRowShift][vecColShift] = secondMatrix[sMatRow * colsCount + sMatCol];
			else
				sMatGroup[vecRowShift][vecColShift] = 0;
		}

		for (int iEl = 0; iEl < LOCAL_GROUP_SIZE; iEl++)
		{
			float4 fMatVector;
			fMatVector.s01 = fMatGroup[iRowLoc][iEl];
			fMatVector.s23 = fMatGroup[iRowLoc + 1][iEl];

			float4 sMatVector;
			sMatVector.s02 = sMatGroup[iEl][iColLoc];
			sMatVector.s13 = sMatGroup[iEl][iColLoc + 1];

			elsValues += fMatVector * sMatVector;
		}
	}


	const bool isCurrRowOk = iRow < rowsCount;
	const bool isNextRowOk = iRow + 1 < rowsCount;
	const bool isCurrColOk = iCol < colsCount;
	const bool isNextColOk = iCol + 1 < colsCount;
	if (isCurrRowOk)
	{
		if (isCurrColOk)
		{
			const uint iS0 = iRow * colsCount + iCol;
			resultMatrix[iS0] = elsValues.s0;
		}
		if (isNextColOk)
		{
			const uint iS1 = iRow * colsCount + (iCol + 1);
			resultMatrix[iS1] = elsValues.s1;
		}
	}
	if (isNextRowOk)
	{
		if (isCurrColOk)
		{
			const uint iS2 = (iRow + 1) * colsCount + iCol;
			resultMatrix[iS2] = elsValues.s2;
		}
		if (isNextColOk)
		{
			const uint iS3 = (iRow + 1) * colsCount + (iCol + 1);
			resultMatrix[iS3] = elsValues.s3;
		}
	}
}
